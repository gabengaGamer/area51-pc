//=============================================================================
//
//  PC Specific Geom Management Routines
//
//=============================================================================


#include "render/lightmgr.hpp"
#include "render/platform_render.hpp"

#include "pc_render.hpp"

static bbox s_CurrentBBox;
static xbool s_bForcedToGlow  = FALSE;
static s32  s_TotalDynLights  = 0;
static f32  s_GlowScale       = 1.0000f;
static f32  s_GlowBeg         = 0.6800f;
static f32  s_GlowEnd         = 0.7500f;
static f32  s_GlowInc         = 0.0050f; // speed of mutation pulsing
static f32  PPL_Max           = 4800.0f;// per pixel lighting max distance

extern void(*g_DrawBeginCB)(void);
extern void(*g_VSyncCB    )(void);

extern xbool g_bClearingViewport;
extern xbool g_bFlippable;
extern xbool g_b480P;
extern xbool g_b720P;

extern u32  g_PhysW;
extern u32  g_PhysH;

#ifndef CONFIG_RETAIL
    xbool g_bShowBackFaces = FALSE;
    xbool g_bFrameScaling  = TRUE ;
#else
#   define g_bShowBackFaces 0
#   define g_bFrameScaling  1
#endif

#ifdef X_DEBUG
static u32 TotalContiguous_General = 0;
static u32 TotalContiguous_Tiled   = 0;
#endif
static u32 TotalPhysicalAvail;
static u32 TotalPhysicalFree;
static u32 GetTotals( void )
{
    MEMORYSTATUS Status;
    GlobalMemoryStatus( &Status );
    TotalPhysicalAvail = Status.dwTotalPhys;
    TotalPhysicalFree  = Status.dwAvailPhys;
    return 0;
}
static u32 InitTotals = GetTotals();

//=============================================================================
//=============================================================================
// Local constants
//=============================================================================
//=============================================================================

#if MAX_VS_LIGHTS > 4
#   error Too many lights!
#endif

static const D3DTRANSFORMSTATETYPE TextureType[4] =
{
    D3DTS_TEXTURE0,
    D3DTS_TEXTURE1,
    D3DTS_TEXTURE2,
    D3DTS_TEXTURE3,
};

enum PipTarget
{
    kTARGET_MAIN,
    kTARGET_PIP,
    kTARGET_OFF
}
s_PipId = kTARGET_OFF;

// This fixes a crash whereby GetSurface() was failing in the pipeline constructor.

//texture_factory::volume_handle pipeline_mgr::m_hAttenuationVolume = NULL;
//texture_factory::handle        pipeline_mgr::m_pTexture[kTOTAL_SLOTS];
//IDirect3DSurface8*             pipeline_mgr::m_pTarget [kTOTAL_SLOTS];
//IDirect3DSurface8*             pipeline_mgr::m_pBkSurface = NULL;
//xbool                          pipeline_mgr::m_NeedsAlloc = TRUE;




//=============================================================================
//=============================================================================
// Blitters
//=============================================================================
//=============================================================================



///////////////////////////////////////////////////////////////////////////////

void Blt( f32 dx,f32 dy,f32 dw,f32 dh,f32 sx,f32 sy,f32 sw,f32 sh )
{
}

///////////////////////////////////////////////////////////////////////////////

static void LightenShadows( f32* pFogColour )
{
}

///////////////////////////////////////////////////////////////////////////////

void Blt( f32 dx,f32 dy,f32 dw,f32 dh,f32 sw,f32 sh )
{
}

///////////////////////////////////////////////////////////////////////////////

void Blt( f32 dx,f32 dy,f32 dw,f32 dh,f32 Fade,f32 sx,f32 sy,f32 sw,f32 sh )
{
}

///////////////////////////////////////////////////////////////////////////////

void Blt( f32 dx,f32 dy,f32 dw,f32 dh,f32 Fade,f32 sw,f32 sh )
{
}

//=============================================================================
//=============================================================================
// External contributors
//=============================================================================
//=============================================================================

///////////////////////////////////////////////////////////////////////////////

f32 FastLog2( f32 x )
{
}

///////////////////////////////////////////////////////////////////////////////

f32 pc_CalcDistance( const matrix4& L2W, const bbox& B )
{
}

///////////////////////////////////////////////////////////////////////////////

s32 pc_GetPipTexture(void)
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_FrameCopy( s32 VRAMID )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_GetRes( s32& XRes,s32& YRes )
{
}

///////////////////////////////////////////////////////////////////////////////

xbool g_bPipelineIn3D = FALSE;

void pc_DrawBeginCB( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_SyncBeginCB( void )
{
}

///////////////////////////////////////////////////////////////////////////////

xbool pc_IsPipTarget( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_SetBackWithZ( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_SetBackSurfaceWithZ( xbool Enable )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_SetFogTarget( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_SetPrimaryTarget( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_SetPipTarget( s32 PipId,s32 W,s32 H )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::ResizePipTexture( s32 W,s32 H )
{
}

///////////////////////////////////////////////////////////////////////////////

template< class T >vert_factory::handle RegisterVerts( const char* pResourceName,T& DList )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_PreRegister( const char* pResourceName,skin_geom* pGeom )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_Unregister( skin_geom* pGeom )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_PreRegister( const char* pResourceName,rigid_geom* pGeom )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_Unregister( rigid_geom* pGeom )
{
}

//=============================================================================
//=============================================================================
// Public methods
//=============================================================================
//=============================================================================

render_target g_RenderTarget;

///////////////////////////////////////////////////////////////////////////////

bool render_target::SetTiled( s32 Target,s32 Depth )
{
}

///////////////////////////////////////////////////////////////////////////////

bool render_target::Set( s32 Target,s32 Depth )
{
}

///////////////////////////////////////////////////////////////////////////////

bool render_target::Set( IDirect3DSurface8* pTarget,IDirect3DSurface8* pDepth )
{
}

///////////////////////////////////////////////////////////////////////////////

bool render_target::SetTile( texture_factory::handle pTarget,texture_factory::handle pDepth )
{
}

///////////////////////////////////////////////////////////////////////////////

void render_target::Push( IDirect3DSurface8* pTarget,IDirect3DSurface8* pDepth )
{
}

///////////////////////////////////////////////////////////////////////////////

void render_target::Pop( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void render_target::Reset( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginRigid( geom* pGeom,s32 iSubMesh )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginSkin( geom* pGeom,s32 iSubMesh )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::End( void )
{
}

///////////////////////////////////////////////////////////////////////////////

pipeline_mgr::~pipeline_mgr( void )
{
}

///////////////////////////////////////////////////////////////////////////////

static void ClearRenderTarget( u32 Target )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::InitialiseTiledMemory( void ) //Useless
{
}

///////////////////////////////////////////////////////////////////////////////

pipeline_mgr::pipeline_mgr( u32 nZones,bool bRunAt60 )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupEnvMap( u32 Flags,const xbitmap* pEnvironmentMap,const xbitmap* pDiffuseMap )
{
}

///////////////////////////////////////////////////////////////////////////////

static bool EyeInMotion( vector3 LastEye[2] )
{
}

///////////////////////////////////////////////////////////////////////////////

extern f32 eng_GetTimings( void );

void pipeline_mgr::BeginNormalRender( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndNormalRender( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginZPrime( void )
{
}

///////////////////////////////////////////////////////////////////////////////

static u32 GetFogColour( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndZPrime( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginLightMap( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndLightMap( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetDefaultDistortion( const radian3& NormalRot )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetEnvDistortion( u32 Flags,const radian3& NormalRot,const xbitmap* pEnvMap )
{
}

///////////////////////////////////////////////////////////////////////////////

bool pipeline_mgr::SetZMaterial( const material& Material )
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  This routine is called to setup light map rendering: black for alpha
//  and self illuminating geometry.
//
void pipeline_mgr::SetLitMaterial( const material& Material )
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  This routine sets render states, textures, and linker flags
//
void pipeline_mgr::SetMaterial( const material& Material )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetSkinConst( skin_geom::command_xbox& Cmd )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::RenderInstance( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SwitchToBackBuffer( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::CalculateViewport( s32 TargetID,D3DVIEWPORT8& Vp )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetRenderTarget( s32 TargetID, s32 DepthID,D3DVIEWPORT8& Vp )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetRenderTarget( s32 TargetID, s32 DepthID )
{
}

///////////////////////////////////////////////////////////////////////////////
//
//  This is where we initialise the frame. It's the first thing to be called.
//
void pipeline_mgr::BeginShadowPass( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndShadowPass( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginShadowReceiveRigid( geom* pGeom,s32 iSubMesh )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::RenderToShadows( render_instance& Inst,s32 iProj )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SkinCastShadow( render_instance& Inst,s32 iProj )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::StartShadowReceive( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndShadowReceive( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginProfiling( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndProfiling( void )
{
}

////////////////////////////////////////////////////////////////////////////////

vector4* pipeline_mgr::SetupLighting( vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::AddDetailMap( vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

bool pipeline_mgr::AddFlashlight( vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::InsertShadow( vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupShadowConsts( void )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupCubeConsts( vs::desc& VSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupTexConsts( ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupDistortion( vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupDistortionConsts( render_instance& Inst )
{
}

////////////////////////////////////////////////////////////////////////////////

bool pipeline_mgr::FogEnable( vs::desc& VSFlags,ps::desc& PSFlags,bool bEnable )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupChannels( vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::AddFilterLight( ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::RenderToZBuffer( render_instance& Inst )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::RenderToLightMap( render_instance& Inst )
{
}

////////////////////////////////////////////////////////////////////////////////
//
// This routine sets per instance render states, constants, and links the
// shader descriptions into vertex and pixel shaders. It also limits what
// colour channels are unnecessary.
//
//  Re: distortion effect
//
//      Position after W2C = [XYZ = -1.0f to 1.0]
//      Scale up to make UVs [0 to 639, 0 to 479]
//      Add normals in viewspace
//      Multiply by scale (4?)
//
//  Fogging only occurs if you call FogEnable() at the end
//  Z Priming takes precedence over everything else
//
////////////////////////////////////////////////////////////////////////////////

bool pipeline_mgr::BeginPass( render_instance& Inst )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetProjectiveTexture( const texture::handle& Texture )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BeginDistortion( void )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::EndDistortion( void )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetProjShadowStage( s32 Index,s32 Stage )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetProjShadowConsts( s32 Index,s32 BaseRegister )
{
}

////////////////////////////////////////////////////////////////////////////////
//
//  Return false if building light map, true otherwise.

void pipeline_mgr::ApplyProjectedShadows( void )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupL2W( render_instance& Inst,vs::desc& VSFlags,ps::desc& PSFlags )
{
}

////////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::RenderToPrimary( render_instance& Inst )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetPipTexture( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::CreateAliasedTarget( s32 TargetID,s32 SourceID,s32 W,s32 H )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetAliasedTarget( s32 TargetID,s32 SourceID,s32 W,s32 H )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::ClearShadowBuffers( u32 nShadowProjectors )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::AddDirShadowProjector( const matrix4& L2W,f32 W,f32 H,f32 NearZ,f32 FarZ )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetZPrime( xbool bZPrime )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BlendEffects( shader_style Style )
{
}

///////////////////////////////////////////////////////////////////////////////

static void SetVert( rigid_geom::vertex_xbox& Vert,f32 dx,f32 dy,f32 sx,f32 sy )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::StoreFrameCopyInfo( s32 VRAMID,f32 U0,f32 V0,f32 U1,f32 V1 )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::CopyFrameTo( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupDepthOfField( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::SetupDownSampling( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::CreateGlowEffect( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::BloomFilter( s32 Source,f32 Width,f32 Height )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::ApplyGlow( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::JitterGlows( void )
{
}

///////////////////////////////////////////////////////////////////////////////

template< class t >void OutputShaderMask( t* pDetails,u32 Count )
{
}

///////////////////////////////////////////////////////////////////////////////

template< class t >bool ExportShaderLibrary( t* pDetails,u32 Count,u32 Size,u32& OldSize,const char* pExt )
{
}

///////////////////////////////////////////////////////////////////////////////

void GpuDone( DWORD Context )
{
}

///////////////////////////////////////////////////////////////////////////////

static void BlurScopeCentre( f32 W0,f32 H0,D3DVIEWPORT8& Vd,D3DVIEWPORT8& Vs )
{
}

///////////////////////////////////////////////////////////////////////////////

static void BlurScopeRemains(  f32 W0,f32 H0,D3DVIEWPORT8& Vd,D3DVIEWPORT8& Vs )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_ApplyScopeBlur( xbitmap& Bitmap,D3DVIEWPORT8& Vd,D3DVIEWPORT8& Vs )
{
}

///////////////////////////////////////////////////////////////////////////////

void pc_GetResolutionText( xwstring& String )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::ApplyFog( void )
{
}

///////////////////////////////////////////////////////////////////////////////

void pipeline_mgr::PostEffect( void )
{
}
